layout(rgba8ui, binding = SAT_INPUT_IMAGE_BINDING) restrict readonly uniform uimage2D img_in;
layout(rgba32ui, binding = SAT_OUTPUT_IMAGE_BINDING) restrict writeonly uniform uimage2D img_out;

layout(local_size_x = SAT_WORKGROUP_SIZE_X) in;

shared uvec4 buf[gl_WorkGroupSize.x * 2];

void main()
{
    // initialize buffer for up-sweep
    int buf_in = 0;
    int buf_out = 1;
    buf[buf_in * gl_WorkGroupSize.x + gl_LocalInvocationID.x] = uvec4(pow(vec4(imageLoad(img_in, ivec2(gl_GlobalInvocationID.xy)) / vec4(255.0)), vec4(1.0 / 2.2)) * 255);
    memoryBarrierShared();

    // perform up-sweep
    for (uint stride = 2; stride <= gl_WorkGroupSize.x; stride *= 2)
    {
        if (((gl_LocalInvocationID.x + 1) & (stride-1)) != 0)
        {
            // nodes that aren't reduced stay the same
            buf[buf_out * gl_WorkGroupSize.x + gl_LocalInvocationID.x] = buf[buf_in * gl_WorkGroupSize.x + gl_LocalInvocationID.x];
        }
        else
        {
            // read the two elements to reduce
            uvec4 a = buf[buf_in * gl_WorkGroupSize.x + gl_LocalInvocationID.x - stride / 2];
            uvec4 b = buf[buf_in * gl_WorkGroupSize.x + gl_LocalInvocationID.x];

            // reduce!
            buf[buf_out * gl_WorkGroupSize.x + gl_LocalInvocationID.x] = a + b;
        }

        memoryBarrierShared();

        // swap buffers
        buf_out = 1 - buf_out;
        buf_in = 1 - buf_in;
    }

    // writeback to output
    imageStore(img_out, ivec2(gl_GlobalInvocationID.xy), buf[buf_in * gl_WorkGroupSize.x + gl_LocalInvocationID.x]);
}